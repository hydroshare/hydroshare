import os
import logging

from django.db import models
from django.template import Template, Context
from django.core.exceptions import ValidationError

from dominate.tags import div, form, button, hr, i

from hs_core.forms import CoverageTemporalForm, CoverageSpatialForm
from hs_core.hydroshare import utils
from hs_core.signals import post_add_generic_aggregation

from base import AbstractFileMetaData, AbstractLogicalFile


class GenericFileMetaDataMixin(AbstractFileMetaData):
    # the metadata element models are from the hs_core type app
    model_app_label = 'hs_core'

    class Meta:
        abstract = True

    def create_element(self, element_model_name, **kwargs):
        element = super(GenericFileMetaDataMixin, self).create_element(element_model_name, **kwargs)
        self.is_dirty = True
        return element

    def delete_element(self, element_model_name, element_id):
        """Overriding the base class method to allow deleting any metadata element that's part of
        generic aggregation (single file aggregation or file set aggregation) metadata"""
        model_type = self._get_metadata_element_model_type(element_model_name)
        meta_element = model_type.model_class().objects.get(id=element_id)
        meta_element.delete()
        self.is_dirty = True
        self.save()

    @property
    def has_modified_metadata(self):
        """Identifies whether a user has updated metadata."""

        if self.coverages.all():
            return True
        if self.extra_metadata:
            return True
        if self.logical_file.files.count() != 1:
            return True
        # the dataset_name is generated by the filename.
        # if dataset_name different than the filename, the user must have updated metadata.
        res_file = self.logical_file.files.first()
        file_name = res_file.file_name[:-len(res_file.extension)]
        if self.logical_file.dataset_name and file_name != self.logical_file.dataset_name:
            return True
        return False

    def get_html(self):
        """overrides the base class function"""

        html_string = super(GenericFileMetaDataMixin, self).get_html()
        if not self.has_metadata:
            no_metadata_message = div(id="#fb-metadata-default", cls="text-center text-muted",
                                      role="alert")
            with no_metadata_message:
                div("No file level metadata exists for the selected file.")
                hr()
                i_tag = i(cls="fa fa-eye-slash fa-2x")
                i_tag['aria-hidden'] = 'true'
            html_string = no_metadata_message.render()
        else:
            if self.temporal_coverage:
                html_string += self.temporal_coverage.get_html()

            if self.spatial_coverage:
                html_string += self.spatial_coverage.get_html()

        template = Template(html_string)
        context = Context({})
        return template.render(context)

    def get_html_forms(self, dataset_name_form=True, temporal_coverage=True):
        """overrides the base class function"""

        root_div = div("{% load crispy_forms_tags %}")
        with root_div:
            super(GenericFileMetaDataMixin, self).get_html_forms()
            with div():
                with form(id="id-coverage-spatial-filetype", action="{{ spatial_form.action }}",
                          method="post", enctype="multipart/form-data", cls='hs-coordinates-picker',
                          data_coordinates_type="point"):
                    div("{% crispy spatial_form %}")
                    with div(cls="row", style="margin-top:10px;"):
                        with div(cls="col-md-offset-10 col-xs-offset-6 "
                                     "col-md-2 col-xs-6"):
                            button("Save changes", type="button",
                                   cls="btn btn-primary pull-right btn-form-submit",
                                   style="display: none;")  # TODO: TESTING
                # for aggregation that contains other aggregations with spatial data,
                # show option to update spatial coverage from contained aggregations
                if self.logical_file.has_children_spatial_data:
                    with div(style="margin-top:20px;"):
                        with div():
                            button("Set spatial coverage from folder contents", type="button",
                                   cls="btn btn-primary pull-right",
                                   id="btn-update-aggregation-spatial-coverage")

        template = Template(root_div.render())
        context_dict = dict()
        temp_cov_form = self.get_temporal_coverage_form()
        spatial_cov_form = self.get_spatial_coverage_form(allow_edit=True)
        update_action = "/hsapi/_internal/{0}/{1}/{2}/{3}/update-file-metadata/"
        create_action = "/hsapi/_internal/{0}/{1}/{2}/add-file-metadata/"

        element_name = "coverage"
        logical_file_class_name = self.logical_file.__class__.__name__
        if self.temporal_coverage or self.spatial_coverage:
            if self.temporal_coverage:
                temp_action = update_action.format(logical_file_class_name, self.logical_file.id,
                                                   element_name, self.temporal_coverage.id)
                temp_cov_form.action = temp_action
            else:
                temp_action = create_action.format(logical_file_class_name, self.logical_file.id,
                                                   element_name)
                temp_cov_form.action = temp_action

            if self.spatial_coverage:
                spatial_action = update_action.format(logical_file_class_name, self.logical_file.id,
                                                      element_name, self.spatial_coverage.id)
                spatial_cov_form.action = spatial_action
            else:
                spatial_action = create_action.format(logical_file_class_name, self.logical_file.id,
                                                      element_name)
                spatial_cov_form.action = spatial_action
        else:
            action = create_action.format(logical_file_class_name, self.logical_file.id,
                                          element_name)
            temp_cov_form.action = action
            spatial_cov_form.action = action

        context_dict["temp_form"] = temp_cov_form
        context_dict["spatial_form"] = spatial_cov_form
        context = Context(context_dict)
        rendered_html = template.render(context)
        return rendered_html

    @classmethod
    def validate_element_data(cls, request, element_name):
        """overriding the base class method"""

        if element_name.lower() not in [el_name.lower() for el_name
                                        in cls.get_supported_element_names()]:
            err_msg = "{} is nor a supported metadata element for Generic file type"
            err_msg = err_msg.format(element_name)
            return {'is_valid': False, 'element_data_dict': None, "errors": err_msg}
        element_name = element_name.lower()
        if element_name == "coverage":
            if 'type' in request.POST:
                if request.POST['type'].lower() == 'point' or request.POST['type'].lower() == 'box':
                    element_form = CoverageSpatialForm(data=request.POST)
                else:
                    element_form = CoverageTemporalForm(data=request.POST)
            else:
                element_form = CoverageTemporalForm(data=request.POST)
        else:
            element_form = CoverageTemporalForm(data=request.POST)

        if element_form.is_valid():
            return {'is_valid': True, 'element_data_dict': element_form.cleaned_data}
        else:
            return {'is_valid': False, 'element_data_dict': None, "errors": element_form.errors}


class GenericFileMetaData(GenericFileMetaDataMixin):
    pass


class GenericLogicalFile(AbstractLogicalFile):
    """ Each resource file is assigned an instance of this logical file type on upload to
    Composite Resource """
    metadata = models.OneToOneField(GenericFileMetaData, related_name="logical_file")
    data_type = "genericData"

    @classmethod
    def create(cls, resource):
        # this custom method MUST be used to create an instance of this class
        generic_metadata = GenericFileMetaData.objects.create(keywords=[])
        # Note we are not creating the logical file record in DB at this point
        # the caller must save this to DB
        return cls(metadata=generic_metadata, resource=resource)

    @staticmethod
    def get_aggregation_display_name():
        return 'Single File Content: A single file with file specific metadata'

    @staticmethod
    def get_aggregation_type_name():
        return "SingleFileAggregation"

    # used in discovery faceting to aggregate native and composite content types
    @staticmethod
    def get_discovery_content_type():
        """Return a human-readable content type for discovery.
        This must agree between Composite Types and native types.
        """
        return "Generic Data"

    @property
    def is_single_file_aggregation(self):
        """This aggregation supports only one file"""
        return True

    @property
    def redirect_url(self):
        """
        return redirect_url if this logical file is a referenced web url file, None otherwise
        """
        if 'url' in self.extra_data:
            return self.extra_data['url']
        else:
            return None

    @classmethod
    def set_file_type(cls, resource, user, file_id=None, folder_path=None, extra_data={}):
        """
        Makes any physical file part of a generic aggregation type. The physical file must
        not already be a part of any aggregation.
        :param resource:
        :param user:
        :param file_id: id of the resource file to set logical file type
        :param folder_path: ignored here and a value for file_id is required
        :param extra_data: a dict that, if not empty, will be passed on to extra_data of
        corresponding logical file of the resource file
        :return:
        """

        log = logging.getLogger()
        if file_id is None:
            raise ValueError("Must specify id of the file to be set as an aggregation type")

        res_file = utils.get_resource_file_by_id(resource, file_id)
        # resource file that is not part of an aggregation or part of a fileset aggregation
        # can be used for creating a single file aggregation
        if res_file.has_logical_file and not res_file.logical_file.is_fileset:
            raise ValidationError("Selected file '{}' is already part of an aggregation".format(
                res_file.file_name))

        logical_file = GenericLogicalFile.create(resource)
        dataset_name, _ = os.path.splitext(res_file.file_name)
        logical_file.dataset_name = dataset_name
        if extra_data:
            logical_file.extra_data = extra_data
        logical_file.save()
        res_file.logical_file_content_object = logical_file
        res_file.save()
        logical_file.create_aggregation_xml_documents()
        log.info("Generic aggregation was created for file:{}.".format(res_file.storage_path))
        post_add_generic_aggregation.send(
            sender=AbstractLogicalFile,
            resource=resource,
            file=logical_file
        )

    def create_aggregation_xml_documents(self, create_map_xml=True):
        super(GenericLogicalFile, self).create_aggregation_xml_documents(create_map_xml)
        self.metadata.is_dirty = False
        self.metadata.save()
